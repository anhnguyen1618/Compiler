structure A = Absyn
		  
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | UMINUS | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 

%nonterm  exp of A.exp
	| program of A.exp
	| lvalue of A.var
	| lvaluetail of A.var
	| record of (A.symbol * A.exp * pos) list
	| array of A.exp
	| sequence of A.exp list
	| fncallexp of A.exp
	| mathexp of A.exp
	| compexp of A.exp
	| boolexp of A.exp
	| assign of A.exp
	| control of A.exp
	| decs of A.dec list
	| dec of A.dec
	| vardec of A.dec
	| fundec of A.dec
	| tydec of A.dec
	| ty of A.ty
	| tyfields of A.field list
	| tyfieldstail of A.field list
	| args of A.exp list
	| argtail of A.exp list
	| seqexp of A.exp
	| seqexptail of A.exp
	| fields of (A.symbol * A.exp * pos) list
	| fieldtail of (A.symbol * A.exp * pos) list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

(* LOW PRECEDENCE *)
%nonassoc FUNCTION VAR TYPE IF THEN ELSE DO OF ASSIGN ARRAY WHILE FOR TO
%left OR
%left AND

%nonassoc EQ NEQ LT LE GT GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS
(* HIGH PRECEDENCE *)


%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(* This is a skeleton grammar file, meant to illustrate what kind of
 * declarations are necessary above the %% mark.  Students are expected
 *  to replace the two dummy productions below with an actual grammar. 
 *)

program	: exp				(exp)

	
exp: lvalue (A.VarExp(lvalue))
   | NIL (A.NilExp)
   | INT (A.IntExp(INT))
   | STRING (A.StringExp(STRING, STRINGleft))
   | sequence (A.SeqExp(sequence))
   | fncallexp (A.CallExp())
   | mathexp ()
   | compexp ()
   | boolexp ()
   | assign ()
   | control ()
   | array ()
   | record ()
	 

decs : dec decs ()
			    
dec : tydec ()
    | vardec ()
    | fundec ()

ty : ID ()
   | LBRACE tyfields RBRACE ()
   | ARRAY OF ID ()

tyfields: (* empty *) ()
	| ID COLON ty tyfieldstail ()

tyfieldstail : (* empty*) ()
	     | COMMA ID COLON ty tyfieldstail ()
			

tydec : TYPE ID EQ ty ()

vardec: VAR ID ASSIGN exp ()
      | VAR ID COLON ty ASSIGN exp ()
	     
fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp ()
       | FUNCTION ID LPAREN tyfields RPAREN COLON ty EQ exp ()
	     
lvalue : ID lvaluetail ()

lvaluetail : (* empty*) ()
	   | DOT ID lvaluetail ()
	   | LBRACK exp RBRACK lvaluetail ()
		
fields : (* empty *) ()
       | ID EQ exp fieldtail (A.field(Symbol.symbol ID, exp, IDleft)::fieldtail)

fieldtail : (* empty *) ([])
	  | COMMA ID EQ exp fieldtail (A.field(Symbol.symbol ID, exp, IDleft)::fieldtail)

record : ID LBRACE fields RBRACE (A.RecordExp({fields = fields, typ = Symbol.symbol ID, posID = IDleft}))

array : ID LBRACK exp RBRACK OF exp (A.ArrayExp({typ = Symbol.symbol ID, size = exp1, init = exp2, pos = IDleft}))
	   
args: (* empty *) ([])
    | exp argtail (exp::argtail)

argtail : (* empty *) ([])
	| COMMA exp argtail (exp::argtail)

seqexp: exp seqexptail (exp::seqexptail)

seqexptail: (* empty *) ([])
	  | SEMICOLON exp seqexptail (exp::seqexptail)

sequence : LPAREN seqexp RPAREN (seqexp)
		  
fncallexp : ID LPAREN args RPAREN (A.CallExp({func = Symbol.symbol ID, args = args, pos = IDleft ))

mathexp : MINUS exp %prec UMINUS (A.OpExp({left=A.IntExp(0), oper=A.MinusOp, right=exp, pos=MINUSleft}))
	| exp PLUS exp (A.OpExp({left=exp1, oper=A.PlusOp, right=exp2, pos=exp1left}))
	| exp MINUS exp (A.OpExp({left=exp1, oper=A.MinusOp, right=exp2, pos=exp1left}))
	| exp TIMES exp (A.OpExp({left=exp1, oper=A.TimesOp, right=exp2, pos=exp1left}))
	| exp DIVIDE exp (A.OpExp({left=exp1, oper=A.DivideOp, right=exp2, pos=exp1left}))

compexp : exp EQ exp (A.OpExp({left=exp1, oper=A.EqOp, right=exp2, pos=exp1left}))
	| exp NEQ exp (A.OpExp({left=exp1, oper=A.NeqOp, right=exp2, pos=exp1left}))
	| exp LT exp (A.OpExp({left=exp1, oper=A.LtOp, right=exp2, pos=exp1left}))
	| exp LE exp (A.OpExp({left=exp1, oper=A.LeOp, right=exp2, pos=exp1left}))
	| exp GT exp (A.OpExp({left=exp1, oper=A.GtOp, right=exp2, pos=exp1left}))
	| exp GE exp (A.OpExp({left=exp1, oper=A.GeOp, right=exp2, pos=exp1left}))

boolexp : exp AND exp (A.IfExp({ test = exp1, then' = exp2, else' = SOME(A.IntExp(0)), pos = exp1left})) 
	| exp OR exp (A.IfExp({ test = exp1, then' = A.IntExp(1), else' = SOME(exp2), pos = exp1left}))
	      
assign : lvalue ASSIGN exp (A.AssignExp({ var = lvalue, exp = exp, pos = ASSIGNleft }))

control : IF exp THEN exp ELSE exp (A.IfExp({ test = exp1, then' = exp2, else' = SOME exp3, pos = IFleft}))
	| IF exp THEN exp (A.IfExp({ test = exp1, then' = exp2, else' = NONE, pos = IFleft}))
	| WHILE exp DO exp (A.WhileExp({test = exp1, body = exp2, pos = WHILEleft}))
	| FOR ID ASSIGN exp TO exp DO exp (A.ForExp({var = Symbol.synbol ID, escape = (ref true), lo = exp1, hi = exp2 , body = exp3, pos = FORleft}))
	| BREAK (A.BreakExp(BREAKleft))
	| LET decs IN seqexp END (A.LetExp({decs = decs, body = seqexp, pos = LETleft }))
